// IMPORTANT:
// Shader passes need to know details about the image in the mask_texture LUT
// files, so set the following constants in user-preset-constants.h accordingly:
// 1.) mask_triads_per_tile = (number of horizontal triads in mask texture LUT's)
// 2.) mask_texture_small_size = (texture size of mask*texture_small LUT's)
// 3.) mask_texture_large_size = (texture size of mask*texture_large LUT's)
// 4.) mask_grille_avg_color = (avg. brightness of mask_grille_texture* LUT's, in [0, 1])
// 5.) mask_slot_avg_color = (avg. brightness of mask_slot_texture* LUT's, in [0, 1])
// 6.) mask_shadow_avg_color = (avg. brightness of mask_shadow_texture* LUT's, in [0, 1])
// Shader passes also need to know certain scales set in this preset, but their
// compilation model doesn't currently allow the preset file to tell them.  Make
// sure to set the following constants in user-preset-constants.h accordingly too:
// 1.) bloom_approx_scale_x = scale_x2
// 2.) mask_resize_viewport_scale = vec2(scale_x6, scale_y5)
// Finally, shader passes need to know the value of geom_max_aspect_ratio used to
// calculate scale_y5 (among other values):
// 1.) geom_max_aspect_ratio = (geom_max_aspect_ratio used to calculate scale_y5)

// Add Mega Screen Scale Params & Initial Prep
//      Add the mega-screen-scale parameters at the beginning of the list for easy access
//      Add Afterglow, Black Level & Gamma
//      Calculate Average Luminance and put in alpha channel
//      Debug Drawing of the resolution/screen scaling
shader0 = ../crt/shaders/HyperspaceMadness/hsm-prep-initial-debug-avgluma-afterglow.slang
alias0  = AvgLumPass

// De-Dithering - Mdapt
shader1 = ../crt/shaders/HyperspaceMadness/hsm-mdapt/hsm-mdapt-pass0.slang
shader2 = ../crt/shaders/HyperspaceMadness/hsm-mdapt/hsm-mdapt-pass1.slang
shader3 = ../crt/shaders/HyperspaceMadness/hsm-mdapt/hsm-mdapt-pass2.slang
shader4 = ../crt/shaders/HyperspaceMadness/hsm-mdapt/hsm-mdapt-pass3.slang
shader5 = ../crt/shaders/HyperspaceMadness/hsm-mdapt/hsm-mdapt-pass4.slang

// GTU TV Processing
shader6 = ../crt/shaders/HyperspaceMadness/hsm-gtu/hsm-gtu-pass1.slang
scale_type6 = source
scale6 = 1.0
float_framebuffer6 = true

shader7 = ../crt/shaders/HyperspaceMadness/hsm-gtu/hsm-gtu-pass2.slang
scale_type_x7 = viewport
scale_x7 = 1.0
scale_type_y7 = source
scale_y7 = 1.0
filter_linear7 = true
float_framebuffer7 = true


// NTSC passes added here so you can swap out with GTU
// shader6 = ../crt/shaders/HyperspaceMadness/hsm-ntsc-adaptive/hsm-ntsc-pass1.slang
// scale_type6 = source
// scale_x6 = 4.0
// filter_linear6 = false
// float_framebuffer6 = true

// Linearize the input based on CRT gamma and bob interlaced fields.
// (Bobbing ensures we can immediately blur without getting artifacts.)
shader8 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-first-pass-linearize-crt-gamma-bob-fields.slang"
alias8 = "ORIG_LINEARIZED"
filter_linear8 = "false"
scale_type8 = "source"
scale8 = "1.0"
srgb_framebuffer8 = "true"

// Pass8: Resample interlaced (and misconverged) scanlines vertically.
// Separating vertical/horizontal scanline sampling is faster: It lets us
// consider more scanlines while calculating weights for fewer pixels, and
// it reduces our samples from vertical*horizontal to vertical+horizontal.
// This has to come right after ORIG_LINEARIZED, because there's no
// "original_source" scale_type we can use later.
shader9 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-scanlines-vertical-interlacing.slang"
alias9 = "VERTICAL_SCANLINES"
filter_linear9 = "true"
scale_type_x9 = "source"
scale_x9 = "1.0"
scale_type_y9 = "viewport"
scale_y9 = "1.0"
srgb_framebuffer9 = "true"

// Pass6: Do a small resize blur of ORIG_LINEARIZED at an absolute size, and
// account for convergence offsets.  We want to blur a predictable portion of the
// screen to match the phosphor bloom, and absolute scale works best for
// reliable results with a fixed-size bloom.  Picking a scale is tricky:
// a.) 400x300 is a good compromise for the "fake-bloom" version: It's low enough
//     to blur high-res/interlaced sources but high enough that resampling
//     doesn't smear low-res sources too much.
// b.) 320x240 works well for the "real bloom" version: It's 1-1.5% faster, and
//     the only noticeable visual difference is a larger halation spread (which
//     may be a good thing for people who like to crank it up).
// Note the 4:3 aspect ratio assumes the input has cropped geom_overscan (so it's
// *intended* for an ~4:3 aspect ratio).
shader10 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-bloom-approx.slang"
alias10 = "BLOOM_APPROX"
filter_linear10 = "true"
scale_type10 = "absolute"
scale_x10 = "320"
scale_y10 = "240"
srgb_framebuffer10 = "true"

// Blur the input for halation and refractive diffusion.
// Base this on BLOOM_APPROX: This blur should be small and fast, and blurring
// a constant portion of the screen is probably physically correct if the
// viewport resolution is proportional to the simulated CRT size.
shader11 = "../blurs/blur9x9.slang"
alias11 = "HALATION_BLUR"
filter_linear11 = "true"
scale_type11 = "source"
scale11 = "1.0"
srgb_framebuffer11 = "true"

// Lanczos-resize the phosphor mask vertically.  Set the absolute
// scale_x9 == mask_texture_small_size.x (see IMPORTANT above).  Larger scales
// will blur, and smaller scales could get nasty.  The vertical size must be
// based on the viewport size and calculated carefully to avoid artifacts later.
// First calculate the minimum number of mask tiles we need to draw.
// Since curvature is computed after the scanline masking pass:
//   num_resized_mask_tiles = 2.0;
// If curvature were computed in the scanline masking pass (it's not):
//   max_mask_texel_border = ~3.0 * (1/3.0 + 4.0*sqrt(2.0) + 0.5 + 1.0);
//   max_mask_tile_border = max_mask_texel_border/
//       (min_resized_phosphor_triad_size * mask_triads_per_tile);
//   num_resized_mask_tiles = max(2.0, 1.0 + max_mask_tile_border * 2.0);
//   At typical values (triad_size >= 2.0, mask_triads_per_tile == 8):
//       num_resized_mask_tiles = ~3.8
// Triad sizes are given in horizontal terms, so we need geom_max_aspect_ratio
// to relate them to vertical resolution.  The widest we expect is:
//   geom_max_aspect_ratio = 4.0/3.0  // Note: Shader passes need to know this!
// The fewer triads we tile across the screen, the larger each triad will be as a
// fraction of the viewport size, and the larger scale_y9 must be to draw a full
// num_resized_mask_tiles.  Therefore, we must decide the smallest number of
// triads we'll guarantee can be displayed on screen.  We'll set this according
// to 3-pixel triads at 768p resolution (the lowest anyone's likely to use):
//   min_allowed_viewport_triads = 768.0*geom_max_aspect_ratio / 3.0 = 341.333333
// Now calculate the viewport scale that ensures we can draw resized_mask_tiles:
//   min_scale_x = resized_mask_tiles * mask_triads_per_tile /
//       min_allowed_viewport_triads
//   scale_y9 = geom_max_aspect_ratio * min_scale_x
//   // Some code might depend on equal scales:
//   scale_x10 = scale_y9
// Given our default geom_max_aspect_ratio and min_allowed_viewport_triads:
//   scale_y9 = 4.0/3.0 * 2.0/(341.33333 / 8.0) = 0.0625
// IMPORTANT: The scales MUST be calculated in this way.  If you wish to change
// geom_max_aspect_ratio, update that constant in user-preset-constants.h!
shader12 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-mask-resize-vertical.slang"
filter_linear12 = "true"
scale_type_x12 = "absolute"
scale_x12 = "64"
scale_type_y12 = "viewport"
scale_y12 = "0.0625" // Safe for >= 341.333 horizontal triads at viewport size
#srgb_framebuffer12 = "false" // mask_texture is already assumed linear

// Lanczos-resize the phosphor mask horizontally.  scale_x13 = scale_y9.
// TODO: Check again if the shaders actually require equal scales.
shader13 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-mask-resize-horizontal.slang"
filter_linear13 = "false"
scale_type_x13 = "viewport"
scale_x13 = "0.0625"
scale_type_y13 = "source"
scale_y13 = "1.0"
#srgb_framebuffer13 = "false" // mask_texture is already assumed linear
alias13 = "MASK_RESIZE"

// Resample (misconverged) scanlines horizontally, apply halation, and
// apply the phosphor mask.
shader14 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-scanlines-horizontal-apply-mask.slang"
filter_linear14 = "true" // This could just as easily be nearest neighbor.
scale_type14 = "viewport"
scale14 = "1.0"
srgb_framebuffer14 = "true"
alias14 = "MASKED_SCANLINES"

// Compute a brightpass.  This will require reading the final mask.
shader15 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-brightpass.slang"
filter_linear15 = "true" // This could just as easily be nearest neighbor.
scale_type15 = "viewport"
scale15 = "1.0"
srgb_framebuffer15 = "true"
alias15 = "BRIGHTPASS"

// Blur the brightpass vertically
shader16 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-bloom-vertical.slang"
filter_linear16 = "true" // This could just as easily be nearest neighbor.
scale_type16 = "source"
scale16 = "1.0"
srgb_framebuffer16 = "true"

// Blur the brightpass horizontally and combine it with the dimpass:
shader17 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-bloom-horizontal-reconstitute.slang"
filter_linear17 = "true"
srgb_framebuffer17 = "true"
scale_type17 = "source"
scale17 = "1.0"
wrap_mode17 = mirrored_repeat
alias17 = BR_CrtPass

// Tube Scale Curvature Mapping
// Write mapping into the pass, of the 4 channels, x & y are tube warped coord and z & w are outside tube mask and edge mask
shader18 = ../crt/shaders/HyperspaceMadness/hsm-curvature-mapping.slang
mipmap_input18 = true
float_framebuffer18 = true
filter_linear18 = true
scale_type18 = viewport
alias18 = BR_MappingPass

// Royale does its curvature as a separate pass, 
// Because of this and the number of max passes available passes 18 & 19 
// are different than the standard set in all the other mega bezel presets
shader19 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/hsm-crt-royale-geometry-aa-last-pass-prep-post-crt-linearize.slang"
mipmap_input19 = true
filter_linear19 = true
float_framebuffer19 = true
wrap_mode19 = mirrored_repeat
alias19 = BR_CRTPreppedLinearPass

// Reduce Resolution  ----------------------------------------------------------------
//      Reduce the resolution to a small static size regardless of final resolution
//      Allows consistent look and faster at different final resolutions for blur
//      Mipmap option allows downscaling without artifacts
shader20 = ../stock.slang
mipmap_input20 = true
filter_linear20 = true
scale_type20 = absolute
float_framebuffer20 = true
// scale_x20 = 480
// scale_y20 = 270
// scale_x20 = 960
// scale_y20 = 540
scale_x20 = 800
scale_y20 = 600
float_framebuffer20 = true

// Add Blur for the Reflection (Horizontal) ----------------------------------------------------------------
shader21 = ../crt/shaders/HyperspaceMadness/hsm-blur-outside-screen-horiz.slang
mipmap_input21 = true
filter_linear21 = true
float_framebuffer21 = true
scale_type22 = source
wrap_mode21 = mirrored_repeat

// Add Blur for the Reflection (Vertical) ----------------------------------------------------------------
shader22 = ../crt/shaders/HyperspaceMadness/hsm-blur-outside-screen-vert.slang
filter_linear22 = false
scale_type22 = source
float_framebuffer22 = true
wrap_mode22 = mirrored_repeat
alias22 = BR_MirrorBlurredPass

// Reduce resolution ----------------------------------------------------------------
// Reduced to a very small amount so we can create a blur which will create a glow from the screen
//      Mipmap option allows smoother downscaling
shader23 = ../blurs/blur9x9.slang
mipmap_input23 = true
filter_linear23 = true
scale_type23 = absolute
float_framebuffer23 = true
scale_x23 = 128
scale_y23 = 128
wrap_mode23 = mirrored_repeat
alias23 = BR_MirrorReflectionDiffusedPass

// Add Diffused glow all around the screen ----------------------------------------------------------------
//      lurred so much that it's non directional
//      Mipmap option allows downscaling without artifacts
shader24 = ../blurs/blur9x9.slang
mipmap_input24 = true
filter_linear24 = true
scale_type24 = absolute
float_framebuffer24 = true
scale_x24 = 12
scale_y24 = 12
wrap_mode24 = mirrored_repeat
alias24 = BR_MirrorFullscreenGlowPass

// Bezel Generation & Reflection ----------------------------------------------------------------
//      Uses these previous passes:
//          BR_CrtPass
//          BR_MirrorBlurredPass
//          BR_MirrorReflectionDiffusedPass
//          BR_MirrorFullscreenGlowPass
//      Blur passes are in linearized color space, and CRT Pass already has gamma encoded in it
//
//      Uses these textures
            // BackgroundImage
            // BackgroundVertImage
            // TubeGlassImage
            // OverlayImage
            // OverlayVertImage

shader25 = ../crt/shaders/HyperspaceMadness/hsm-mega-bezel-reflection.slang
mipmap_input25 = true
filter_linear25 = true
scale_type25 = viewport
float_framebuffer25 = false

// Define how many shaders will be used from this list
shaders = 26


// Set an identifier, filename, and sampling traits for the phosphor mask texture.
// Load an aperture grille, slot mask, and an EDP shadow mask, and load a small
// non-mipmapped version and a large mipmapped version.
// TODO: Test masks in other directories.
textures = "mask_grille_texture_small;mask_slot_texture_small;mask_shadow_texture_small;BackgroundImage;BackgroundVertImage;TubeGlassImage;OverlayImage;OverlayVertImage;"
mask_grille_texture_small = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/TileableLinearApertureGrille15Wide8And5d5SpacingResizeTo64.png"
// mask_grille_texture_large = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/TileableLinearApertureGrille15Wide8And5d5Spacing.png"
mask_slot_texture_small = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/TileableLinearSlotMaskTall15Wide9And4d5Horizontal9d14VerticalSpacingResizeTo64.png"
// mask_slot_texture_large = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/TileableLinearSlotMaskTall15Wide9And4d5Horizontal9d14VerticalSpacing.png"
mask_shadow_texture_small = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/TileableLinearShadowMaskEDPResizeTo64.png"
// mask_shadow_texture_large = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/TileableLinearShadowMaskEDP.png"
mask_grille_texture_small_wrap_mode = "repeat"
// mask_grille_texture_large_wrap_mode = "repeat"
mask_slot_texture_small_wrap_mode = "repeat"
// mask_slot_texture_large_wrap_mode = "repeat"
mask_shadow_texture_small_wrap_mode = "repeat"
// mask_shadow_texture_large_wrap_mode = "repeat"
mask_grille_texture_small_linear = "true"
// mask_grille_texture_large_linear = "true"
mask_slot_texture_small_linear = "true"
// mask_slot_texture_large_linear = "true"
mask_shadow_texture_small_linear = "true"
// mask_shadow_texture_large_linear = "true"
mask_grille_texture_small_mipmap = "false"  // Mipmapping causes artifacts with manually resized masks without tex2Dlod
// mask_grille_texture_large_mipmap = "true"   // Essential for hardware-resized masks
mask_slot_texture_small_mipmap = "false"    // Mipmapping causes artifacts with manually resized masks without tex2Dlod
// mask_slot_texture_large_mipmap = "true"     // Essential for hardware-resized masks
mask_shadow_texture_small_mipmap = "false"  // Mipmapping causes artifacts with manually resized masks without tex2Dlod
// mask_shadow_texture_large_mipmap = "true"   // Essential for hardware-resized masks

BackgroundImage = ../crt/shaders/HyperspaceMadness/textures/BackgroundImage_3840x2160.png
BackgroundVertImage = ../crt/shaders/HyperspaceMadness/textures/BackgroundImage_3840x2160.png
TubeGlassImage = ../crt/shaders/HyperspaceMadness/textures/TubeGlassOverlayImage_3840x2160.png
OverlayImage = ../crt/shaders/HyperspaceMadness/textures/OverlayImage_OverReflection_3840x2160.png
OverlayVertImage = ../crt/shaders/HyperspaceMadness/textures/OverlayImage_OverReflection_3840x2160.png

parameters = "hmss_curvature_mode;hmss_curvature_3D_radius;hmss_curvature_3D_view_dist;geom_overscan_x;geom_overscan_y;border_size;border_compress;interlace_detect_toggle;hmss_mega_screen_scale_on;hmss_screen_aspect_ratio;hmss_integer_scale_mode;hmss_int_scale_multiple_offset;hmss_non_integer_scale;hmss_int_scale_border_min_height;hmss_scanline_direction;hmss_curvature_2D_long_axis;hmss_curvature_2D_short_axis;hmss_corner_radius;hmss_tube_black_edge_thickness;hmbz_frame_thickness;hmbz_bezel_width;hmbz_bezel_height;hmbz_background_image_opacity;hmbz_bezel_opacity;hmbz_bezel_brightness;hmbz_frame_opacity;hmbz_background_image_scale_mode;hmbz_background_image_aspect_ratio;hmbz_background_image_tube_height;hmss_crop_overscan_top;hmss_crop_overscan_bottom;hmss_crop_overscan_left;hmss_crop_overscan_right;hmss_pre_crt_black_level;hbl_blur_min;hbl_blur_max;hbr_global_amount;hbr_global_gamma_adjust;hbr_diffused_reflection;hbr_fullscreen_glow;hbr_fullscreen_glow_gamma;hag_afterglow_persistence"

// geom_overscan_x = 0.985;
// geom_overscan_y = 0.985;
border_size = 0.005;
border_compress = 5;
interlace_detect_toggle = 0;

hmss_mega_screen_scale_on = 1
// hmss_screen_aspect_ratio = 1.5
// hmss_integer_scale_mode = 1
// hmss_int_scale_multiple_offset = 0
// hmss_non_integer_scale = 83
hmss_int_scale_border_min_height = 5.5
// hmss_scanline_direction = 0

hmss_curvature_mode = 2
hmss_curvature_2D_long_axis = 0
hmss_curvature_2D_short_axis = 0
hmss_curvature_3D_radius = 2
hmss_curvature_3D_view_dist = 2
hmss_corner_radius = 10

// hmss_tube_black_edge_thickness = 1.6
// hmbz_bezel_width = 7.5;
// hmbz_bezel_height = 6;
// hmbz_frame_thickness = 7;
 
// hmbz_background_image_opacity = 1
// hmbz_bezel_opacity = 1
// hmbz_bezel_brightness = 10
// hmbz_frame_opacity = 1;

// hmbz_background_image_scale_mode = 0
hmbz_background_image_aspect_ratio = 1.75
// hmbz_background_image_tube_height = 69

// hmss_crop_overscan_top = 0
// hmss_crop_overscan_bottom = 0
// hmss_crop_overscan_left = 0
// hmss_crop_overscan_right = 0
// hmss_pre_crt_black_level = 0

// hbl_blur_min = 0
// hbl_blur_max = 0.4



// hbr_global_amount = 1.4
// hbr_global_gamma_adjust = 1.2
// hbr_diffused_reflection = 0
// hbr_fullscreen_glow = 300
// hbr_fullscreen_glow_gamma = 1.6

// hag_afterglow_persistence = 0.2