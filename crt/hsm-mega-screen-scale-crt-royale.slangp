# IMPORTANT:
# Shader passes need to know details about the image in the mask_texture LUT
# files, so set the following constants in user-preset-constants.h accordingly:
# 1.) mask_triads_per_tile = (number of horizontal triads in mask texture LUT's)
# 2.) mask_texture_small_size = (texture size of mask*texture_small LUT's)
# 3.) mask_texture_large_size = (texture size of mask*texture_large LUT's)
# 4.) mask_grille_avg_color = (avg. brightness of mask_grille_texture* LUT's, in [0, 1])
# 5.) mask_slot_avg_color = (avg. brightness of mask_slot_texture* LUT's, in [0, 1])
# 6.) mask_shadow_avg_color = (avg. brightness of mask_shadow_texture* LUT's, in [0, 1])
# Shader passes also need to know certain scales set in this preset, but their
# compilation model doesn't currently allow the preset file to tell them.  Make
# sure to set the following constants in user-preset-constants.h accordingly too:
# 1.) bloom_approx_scale_x = scale_x2
# 2.) mask_resize_viewport_scale = vec2(scale_x6, scale_y5)
# Finally, shader passes need to know the value of geom_max_aspect_ratio used to
# calculate scale_y5 (among other values):
# 1.) geom_max_aspect_ratio = (geom_max_aspect_ratio used to calculate scale_y5)

// Add Mega Screen Scale Params & Initial Prep
//      Add the mega-screen-scale parameters at the beginning of the list for easy access
//      Add Afterglow, Black Level & Gamma
//      Calculate Average Luminance and put in alpha channel
//      Debug Drawing of the resolution/screen scaling
shader0 = ../crt/shaders/HyperspaceMadness/hsm-prep-initial-debug-avgluma-afterglow-screen-scale-only.slang
alias0  = AvgLumPass

// Linearize the input based on CRT gamma and bob interlaced fields.
// (Bobbing ensures we can immediately blur without getting artifacts.)
shader1 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-first-pass-linearize-crt-gamma-bob-fields.slang"
alias1 = "ORIG_LINEARIZED"
filter_linear1 = "false"
scale_type1 = "source"
scale1 = "1.0"
srgb_framebuffer1 = "true"

// Pass8: Resample interlaced (and misconverged) scanlines vertically.
// Separating vertical/horizontal scanline sampling is faster: It lets us
// consider more scanlines while calculating weights for fewer pixels, and
// it reduces our samples from vertical*horizontal to vertical+horizontal.
// This has to come right after ORIG_LINEARIZED, because there's no
// "original_source" scale_type we can use later.
shader2 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-scanlines-vertical-interlacing.slang"
alias2 = "VERTICAL_SCANLINES"
filter_linear2 = "true"
scale_type_x2 = "source"
scale_x2 = "1.0"
scale_type_y2 = "viewport"
scale_y2 = "1.0"
srgb_framebuffer2 = "true"

// Pass6: Do a small resize blur of ORIG_LINEARIZED at an absolute size, and
// account for convergence offsets.  We want to blur a predictable portion of the
// screen to match the phosphor bloom, and absolute scale works best for
// reliable results with a fixed-size bloom.  Picking a scale is tricky:
// a.) 400x300 is a good compromise for the "fake-bloom" version: It's low enough
//     to blur high-res/interlaced sources but high enough that resampling
//     doesn't smear low-res sources too much.
// b.) 320x240 works well for the "real bloom" version: It's 1-1.5% faster, and
//     the only noticeable visual difference is a larger halation spread (which
//     may be a good thing for people who like to crank it up).
// Note the 4:3 aspect ratio assumes the input has cropped geom_overscan (so it's
// *intended* for an ~4:3 aspect ratio).
shader3 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-bloom-approx.slang"
alias3 = "BLOOM_APPROX"
filter_linear3 = "true"
scale_type3 = "absolute"
scale_x3 = "320"
scale_y3 = "240"
srgb_framebuffer3 = "true"

// Blur the input for halation and refractive diffusion.
// Base this on BLOOM_APPROX: This blur should be small and fast, and blurring
// a constant portion of the screen is probably physically correct if the
// viewport resolution is proportional to the simulated CRT size.
shader4 = "../blurs/blur9x9.slang"
alias4 = "HALATION_BLUR"
filter_linear4 = "true"
scale_type4 = "source"
scale4 = "1.0"
srgb_framebuffer4 = "true"

// Lanczos-resize the phosphor mask vertically.  Set the absolute
// scale_x9 == mask_texture_small_size.x (see IMPORTANT above).  Larger scales
// will blur, and smaller scales could get nasty.  The vertical size must be
// based on the viewport size and calculated carefully to avoid artifacts later.
// First calculate the minimum number of mask tiles we need to draw.
// Since curvature is computed after the scanline masking pass:
//   num_resized_mask_tiles = 2.0;
// If curvature were computed in the scanline masking pass (it's not):
//   max_mask_texel_border = ~3.0 * (1/3.0 + 4.0*sqrt(2.0) + 0.5 + 1.0);
//   max_mask_tile_border = max_mask_texel_border/
//       (min_resized_phosphor_triad_size * mask_triads_per_tile);
//   num_resized_mask_tiles = max(2.0, 1.0 + max_mask_tile_border * 2.0);
//   At typical values (triad_size >= 2.0, mask_triads_per_tile == 8):
//       num_resized_mask_tiles = ~3.8
// Triad sizes are given in horizontal terms, so we need geom_max_aspect_ratio
// to relate them to vertical resolution.  The widest we expect is:
//   geom_max_aspect_ratio = 4.0/3.0  // Note: Shader passes need to know this!
// The fewer triads we tile across the screen, the larger each triad will be as a
// fraction of the viewport size, and the larger scale_y9 must be to draw a full
// num_resized_mask_tiles.  Therefore, we must decide the smallest number of
// triads we'll guarantee can be displayed on screen.  We'll set this according
// to 3-pixel triads at 768p resolution (the lowest anyone's likely to use):
//   min_allowed_viewport_triads = 768.0*geom_max_aspect_ratio / 3.0 = 341.333333
// Now calculate the viewport scale that ensures we can draw resized_mask_tiles:
//   min_scale_x = resized_mask_tiles * mask_triads_per_tile /
//       min_allowed_viewport_triads
//   scale_y9 = geom_max_aspect_ratio * min_scale_x
//   // Some code might depend on equal scales:
//   scale_x10 = scale_y9
// Given our default geom_max_aspect_ratio and min_allowed_viewport_triads:
//   scale_y9 = 4.0/3.0 * 2.0/(341.33333 / 8.0) = 0.0625
// IMPORTANT: The scales MUST be calculated in this way.  If you wish to change
// geom_max_aspect_ratio, update that constant in user-preset-constants.h!
shader5 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-mask-resize-vertical.slang"
filter_linear5 = "true"
scale_type_x5 = "absolute"
scale_x5 = "64"
scale_type_y5 = "viewport"
scale_y5 = "0.0625" // Safe for >= 341.333 horizontal triads at viewport size
#srgb_framebuffer5 = "false" // mask_texture is already assumed linear

// Lanczos-resize the phosphor mask horizontally.  scale_x13 = scale_y9.
// TODO: Check again if the shaders actually require equal scales.
shader6 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-mask-resize-horizontal.slang"
filter_linear6 = "false"
scale_type_x6 = "viewport"
scale_x6 = "0.0625"
scale_type_y6 = "source"
scale_y6 = "1.0"
#srgb_framebuffer6 = "false" // mask_texture is already assumed linear
alias6 = "MASK_RESIZE"

// Resample (misconverged) scanlines horizontally, apply halation, and
// apply the phosphor mask.
shader7 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-scanlines-horizontal-apply-mask.slang"
filter_linear7 = "true" // This could just as easily be nearest neighbor.
scale_type7 = "viewport"
scale7 = "1.0"
srgb_framebuffer7 = "true"
alias7 = "MASKED_SCANLINES"

// Compute a brightpass.  This will require reading the final mask.
shader8 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-brightpass.slang"
filter_linear8 = "true" // This could just as easily be nearest neighbor.
scale_type8 = "viewport"
scale8 = "1.0"
srgb_framebuffer8 = "true"
alias8 = "BRIGHTPASS"

// Blur the brightpass vertically
shader9 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-bloom-vertical.slang"
filter_linear9 = "true" // This could just as easily be nearest neighbor.
scale_type9 = "source"
scale9 = "1.0"
srgb_framebuffer9 = "true"

// Blur the brightpass horizontally and combine it with the dimpass:
shader10 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/crt-royale-bloom-horizontal-reconstitute.slang"
filter_linear10 = "true"
srgb_framebuffer10 = "true"
scale_type10 = "source"
scale10 = "1.0"
wrap_mode10 = mirrored_repeat
alias10 = BR_CRTPass

// Royale does its curvature as a separate pass, 
// Because of this and the number of max passes available passes 18 & 19 
// are different than the standard set in all the other mega bezel presets
shader11 = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/src/hsm-crt-royale-geometry-aa-last-pass.slang"
mipmap_input11 = true
filter_linear11 = true
float_framebuffer11 = true
wrap_mode11 = mirrored_repeat
alias11 = BR_CRTPreppedLinearPass

shaders = "12"


# Set an identifier, filename, and sampling traits for the phosphor mask texture.
# Load an aperture grille, slot mask, and an EDP shadow mask, and load a small
# non-mipmapped version and a large mipmapped version.
# TODO: Test masks in other directories.
textures = "mask_grille_texture_small;mask_grille_texture_large;mask_slot_texture_small;mask_slot_texture_large;mask_shadow_texture_small;mask_shadow_texture_large"
mask_grille_texture_small = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/TileableLinearApertureGrille15Wide8And5d5SpacingResizeTo64.png"
mask_grille_texture_large = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/TileableLinearApertureGrille15Wide8And5d5Spacing.png"
mask_slot_texture_small = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/TileableLinearSlotMaskTall15Wide9And4d5Horizontal9d14VerticalSpacingResizeTo64.png"
mask_slot_texture_large = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/TileableLinearSlotMaskTall15Wide9And4d5Horizontal9d14VerticalSpacing.png"
mask_shadow_texture_small = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/TileableLinearShadowMaskEDPResizeTo64.png"
mask_shadow_texture_large = "../crt/shaders/HyperspaceMadness/hsm-crt-royale/TileableLinearShadowMaskEDP.png"
mask_grille_texture_small_wrap_mode = "repeat"
mask_grille_texture_large_wrap_mode = "repeat"
mask_slot_texture_small_wrap_mode = "repeat"
mask_slot_texture_large_wrap_mode = "repeat"
mask_shadow_texture_small_wrap_mode = "repeat"
mask_shadow_texture_large_wrap_mode = "repeat"
mask_grille_texture_small_linear = "true"
mask_grille_texture_large_linear = "true"
mask_slot_texture_small_linear = "true"
mask_slot_texture_large_linear = "true"
mask_shadow_texture_small_linear = "true"
mask_shadow_texture_large_linear = "true"
mask_grille_texture_small_mipmap = "false"  # Mipmapping causes artifacts with manually resized masks without tex2Dlod
mask_grille_texture_large_mipmap = "true"   # Essential for hardware-resized masks
mask_slot_texture_small_mipmap = "false"    # Mipmapping causes artifacts with manually resized masks without tex2Dlod
mask_slot_texture_large_mipmap = "true"     # Essential for hardware-resized masks
mask_shadow_texture_small_mipmap = "false"  # Mipmapping causes artifacts with manually resized masks without tex2Dlod
mask_shadow_texture_large_mipmap = "true"   # Essential for hardware-resized masks

parameters = "hmss_curvature_mode;hmss_curvature_3D_radius;hmss_curvature_3D_view_dist;hmss_curvature_3D_radius;border_size;border_compress;interlace_detect_toggle;hmss_mega_screen_scale_on;hmss_screen_aspect_ratio;hmss_integer_scale_mode;hmss_int_scale_multiple_offset;hmss_non_integer_scale;hmss_int_scale_border_min_height;hmss_scanline_direction;hmss_curvature_2D_long_axis;hmss_curvature_2D_short_axis;hmss_corner_radius;hmss_tube_black_edge_thickness;hmbz_frame_thickness;hmbz_bezel_width;hmbz_bezel_height;hmbz_background_image_opacity;hmbz_bezel_opacity;hmbz_bezel_brightness;hmbz_frame_opacity;hmbz_background_image_scale_mode;hmbz_background_image_aspect_ratio;hmbz_background_image_tube_height;hmss_crop_overscan_top;hmss_crop_overscan_bottom;hmss_crop_overscan_left;hmss_crop_overscan_right;hmss_pre_crt_black_level;hbl_blur_min;hbl_blur_max;hbr_global_amount;hbr_global_gamma_adjust;hbr_diffused_reflection;hbr_fullscreen_glow;hbr_fullscreen_glow_gamma;hag_afterglow_persistence"


border_size = 0.005;
border_compress = 5;
interlace_detect_toggle = 0;

hmss_mega_screen_scale_on = 1
// hmss_screen_aspect_ratio = 1.5
// hmss_integer_scale_mode = 1
// hmss_int_scale_multiple_offset = 0
// hmss_non_integer_scale = 83
hmss_int_scale_border_min_height = 5.5
// hmss_scanline_direction = 0

hmss_curvature_mode = 2
hmss_curvature_2D_long_axis = 0
hmss_curvature_2D_short_axis = 0
hmss_curvature_3D_radius = 2
hmss_curvature_3D_view_dist = 2
hmss_corner_radius = 10

// hmss_tube_black_edge_thickness = 1.6

// hmss_crop_overscan_top = 0
// hmss_crop_overscan_bottom = 0
// hmss_crop_overscan_left = 0
// hmss_crop_overscan_right = 0
// hmss_pre_crt_black_level = 0


// hag_afterglow_persistence = 0.2